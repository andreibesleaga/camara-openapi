const fs = require('fs');
const path = require('path');
const yaml = require('js-yaml');
const SwaggerParser = require('@apidevtools/swagger-parser');

// Helper function to escape strings for use in a RegExp
function escapeRegExp(string) {
  return string.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
}

async function mergeApiSpecs() {
  const configPath = path.join(__dirname, '..', 'apis.yaml');
  const config = yaml.load(fs.readFileSync(configPath, 'utf8'));

  const masterSpec = {
    openapi: '3.0.3',
    info: {
      title: 'CAMARA Complete Unified API',
      version: new Date().toISOString().split('T')[0],
      description: 'A single OpenAPI spec generated by merging all active CAMARA project APIs. All paths and components are prefixed to ensure uniqueness.',
      license: {
        name: 'Apache 2.0',
        url: 'https://www.apache.org/licenses/LICENSE-2.0.html'
      }
    },
    servers: [
      {
        url: 'https://api.example.com/camara',
        description: 'Example Production Server'
      }
    ],
    paths: {},
    components: {
      schemas: {},
      securitySchemes: {},
      responses: {},
      parameters: {},
      examples: {},
      requestBodies: {},
      headers: {},
      links: {},
      callbacks: {},
    },
    security: [],
    tags: [],
  };

  for (const api of config.apis) {
    if (!api.enabled) {
      console.log(`Skipping disabled API: ${api.id}`);
      continue;
    }

    try {
      console.log(`Processing API: ${api.id} from ${api.url}`);
      
      const spec = await SwaggerParser.bundle(api.url);
      const prefix = api.id;
      masterSpec.tags.push({ name: prefix, description: spec.info.title });
      
      let specString = JSON.stringify(spec);

      if (spec.components) {
        for (const compType in spec.components) {
          for (const compName in spec.components[compType]) {
            const originalRef = `#/components/${compType}/${compName}`;
            const newRef = `#/components/${compType}/${prefix}${compName}`;
            const searchRegex = new RegExp(`"${escapeRegExp(originalRef)}"`, 'g');
            specString = specString.replace(searchRegex, `"${newRef}"`);
          }
        }
      }

      const updatedSpec = JSON.parse(specString);

      // Merge Paths
      if (updatedSpec.paths) {
          for (const p in updatedSpec.paths) {
            const newPath = `/${prefix.toLowerCase()}${p}`;
            const pathItem = updatedSpec.paths[p];
            for (const method in pathItem) {
                if (typeof pathItem[method] !== 'object' || pathItem[method] === null) continue;
                const operation = pathItem[method];
                if (operation.operationId) {
                    operation.operationId = `${prefix}_${operation.operationId}`;
                }
                operation.tags = [prefix];

                // FIX #3: Handle unique operationId within callbacks.
                if (operation.callbacks) {
                    for (const cbName in operation.callbacks) {
                        const callback = operation.callbacks[cbName];
                        for (const cbPath in callback) {
                            const cbPathItem = callback[cbPath];
                            for (const cbMethod in cbPathItem) {
                                if (cbPathItem[cbMethod] && cbPathItem[cbMethod].operationId) {
                                    cbPathItem[cbMethod].operationId = `${prefix}_callback_${cbPathItem[cbMethod].operationId}`;
                                }
                            }
                        }
                    }
                }
            }
            masterSpec.paths[newPath] = pathItem;
          }
      }

      // Merge Components
      if (updatedSpec.components) {
          for (const compType in updatedSpec.components) {
              if (!masterSpec.components[compType]) masterSpec.components[compType] = {};
              for (const compName in updatedSpec.components[compType]) {
                  const newName = `${prefix}${compName}`;
                  masterSpec.components[compType][newName] = updatedSpec.components[compType][compName];
              }
          }
      }
      
      // Merge security schemes uniquely
      if (updatedSpec.components && updatedSpec.components.securitySchemes) {
        for (const schemeName in updatedSpec.components.securitySchemes) {
          if (!masterSpec.components.securitySchemes[schemeName]) {
            masterSpec.components.securitySchemes[schemeName] = updatedSpec.components.securitySchemes[schemeName];
          }
        }
      }

    } catch (error) {
      console.error(`\n--- ERROR processing API: ${api.id} ---`);
      console.error(`URL: ${api.url}`);
      console.error(error.message);
      console.error(`--- END ERROR ---\n`);
    }
  }

  const outputPath = path.join(__dirname, '..', 'dist');
  if (!fs.existsSync(outputPath)) {
    fs.mkdirSync(outputPath);
  }
  fs.writeFileSync(
    path.join(outputPath, 'camara-openapi.yaml'),
    yaml.dump(masterSpec, { noRefs: true, lineWidth: -1, quotingType: '"' }),
    'utf8'
  );

  console.log('Master OpenAPI spec generated successfully!');
}

mergeApiSpecs();