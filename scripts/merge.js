const fs = require('fs');
const path = require('path');
const yaml = require('js-yaml');
const axios = require('axios');

// Function to recursively find and replace $ref values
function updateRefs(obj, prefix) {
  for (const key in obj) {
    if (key === '$ref' && typeof obj[key] === 'string' && obj[key].startsWith('#/components/')) {
      const refParts = obj[key].split('/');
      const componentName = refParts.pop();
      refParts.push(`${prefix}${componentName}`);
      obj[key] = refParts.join('/');
    } else if (typeof obj[key] === 'object' && obj[key] !== null) {
      updateRefs(obj[key], prefix);
    }
  }
}

async function mergeApiSpecs() {
  const configPath = path.join(__dirname, '..', 'apis.yaml');
  const config = yaml.load(fs.readFileSync(configPath, 'utf8'));

  const masterSpec = {
    openapi: '3.0.3',
    info: {
      title: 'CAMARA Complete Unified API',
      version: new Date().toISOString().split('T')[0], // Use date as version
      description: 'A single OpenAPI spec generated by merging all active CAMARA project APIs.',
    },
    paths: {},
    components: {
      schemas: {},
      securitySchemes: {},
      responses: {},
      parameters: {},
    },
    security: [],
    tags: [],
  };

  for (const api of config.apis) {
    if (!api.enabled) {
      console.log(`Skipping disabled API: ${api.id}`);
      continue;
    }

    try {
      console.log(`Fetching API: ${api.id} from ${api.url}`);
      const response = await axios.get(api.url);
      const spec = yaml.load(response.data);

      const prefix = api.id;
      masterSpec.tags.push({ name: prefix, description: spec.info.title });

      // 1. Merge and prefix paths
      for (const p in spec.paths) {
        const newPath = `/${prefix.toLowerCase()}${p}`;
        masterSpec.paths[newPath] = spec.paths[p];
        // Add tag to each operation
        for (const method in masterSpec.paths[newPath]) {
          masterSpec.paths[newPath][method].tags = [prefix];
        }
        updateRefs(masterSpec.paths[newPath], prefix);
      }

      // 2. Merge and prefix components
      if (spec.components) {
        for (const compType in spec.components) {
          if (!masterSpec.components[compType]) masterSpec.components[compType] = {};
          for (const compName in spec.components[compType]) {
            const newName = `${prefix}${compName}`;
            masterSpec.components[compType][newName] = spec.components[compType][compName];
            updateRefs(masterSpec.components[compType][newName], prefix);
          }
        }
      }
       // 3. Merge security schemes uniquely (assuming they are common)
       if(spec.components && spec.components.securitySchemes){
         Object.assign(masterSpec.components.securitySchemes, spec.components.securitySchemes);
       }


    } catch (error) {
      console.error(`Failed to fetch or process API ${api.id}:`, error.message);
    }
  }

  const outputPath = path.join(__dirname, '..', 'dist');
  if (!fs.existsSync(outputPath)) {
    fs.mkdirSync(outputPath);
  }
  fs.writeFileSync(
    path.join(outputPath, 'camara-complete.yaml'),
    yaml.dump(masterSpec, { noRefs: true, lineWidth: -1 }),
    'utf8'
  );

  console.log('Master OpenAPI spec generated successfully!');
}

mergeApiSpecs();
