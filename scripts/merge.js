const fs = require('fs');
const path = require('path');
const yaml = require('js-yaml');
const SwaggerParser = require('@apidevtools/swagger-parser');

// Helper function to escape strings for use in a RegExp
function escapeRegExp(string) {
  return string.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
}

async function mergeApiSpecs() {
  const configPath = path.join(__dirname, '..', 'apis.yaml');
  const config = yaml.load(fs.readFileSync(configPath, 'utf8'));

  const masterSpec = {
    openapi: '3.0.3',
    info: {
      title: 'CAMARA Complete Unified API',
      version: new Date().toISOString().split('T')[0], // Use date as version
      description: 'A single OpenAPI spec generated by merging all active CAMARA project APIs. All paths and components are prefixed to ensure uniqueness.',
    },
    paths: {},
    components: {
      schemas: {},
      securitySchemes: {},
      responses: {},
      parameters: {},
      examples: {},
      requestBodies: {},
      headers: {},
      links: {},
      callbacks: {},
    },
    security: [],
    tags: [],
  };

  for (const api of config.apis) {
    if (!api.enabled) {
      console.log(`Skipping disabled API: ${api.id}`);
      continue;
    }

    try {
      console.log(`Processing API: ${api.id} from ${api.url}`);
      
      // Step 1: Bundle the spec to resolve all external/file references into one object.
      const spec = await SwaggerParser.bundle(api.url);

      const prefix = api.id;
      masterSpec.tags.push({ name: prefix, description: spec.info.title });
      
      // CRITICAL FIX: Instead of complex object manipulation, we serialize, search-and-replace, and deserialize.
      // This is a more robust way to ensure all internal $refs are prefixed.
      let specString = JSON.stringify(spec);

      if (spec.components) {
        for (const compType in spec.components) {
          for (const compName in spec.components[compType]) {
            const originalRef = `#/components/${compType}/${compName}`;
            const newRef = `#/components/${compType}/${prefix}${compName}`;
            
            // Create a highly specific regex to only replace the exact reference string.
            const searchRegex = new RegExp(`"${escapeRegExp(originalRef)}"`, 'g');
            specString = specString.replace(searchRegex, `"${newRef}"`);
          }
        }
      }

      const updatedSpec = JSON.parse(specString);

      // Step 2: Now merge the fully resolved and reference-updated spec into the master.
      // Merge Paths
      if (updatedSpec.paths) {
          for (const p in updatedSpec.paths) {
            const newPath = `/${prefix.toLowerCase()}${p}`;
            const pathItem = updatedSpec.paths[p];
            for (const method in pathItem) {
                const operation = pathItem[method];
                if (operation.operationId) {
                    operation.operationId = `${prefix}_${operation.operationId}`;
                }
                operation.tags = [prefix];
            }
            masterSpec.paths[newPath] = pathItem;
          }
      }

      // Merge Components (with their new prefixed names)
      if (updatedSpec.components) {
          for (const compType in updatedSpec.components) {
              if (!masterSpec.components[compType]) masterSpec.components[compType] = {};
              for (const compName in updatedSpec.components[compType]) {
                  const newName = `${prefix}${compName}`;
                  masterSpec.components[compType][newName] = updatedSpec.components[compType][compName];
              }
          }
      }
      
      // Merge security schemes uniquely
      if (updatedSpec.components && updatedSpec.components.securitySchemes) {
        for (const schemeName in updatedSpec.components.securitySchemes) {
          if (!masterSpec.components.securitySchemes[schemeName]) {
            masterSpec.components.securitySchemes[schemeName] = updatedSpec.components.securitySchemes[schemeName];
          }
        }
      }

    } catch (error) {
      console.error(`\n--- ERROR processing API: ${api.id} ---`);
      console.error(`URL: ${api.url}`);
      console.error(error.message);
      console.error(`--- END ERROR ---\n`);
      // Optional: decide if you want the whole build to fail on a single API error
      // process.exit(1); 
    }
  }

  const outputPath = path.join(__dirname, '..', 'dist');
  if (!fs.existsSync(outputPath)) {
    fs.mkdirSync(outputPath);
  }
  fs.writeFileSync(
    path.join(outputPath, 'camara-complete.yaml'),
    yaml.dump(masterSpec, { noRefs: true, lineWidth: -1, quotingType: '"' }),
    'utf8'
  );

  console.log('Master OpenAPI spec generated successfully!');
}

mergeApiSpecs();
