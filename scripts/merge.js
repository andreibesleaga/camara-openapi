const fs = require('fs');
const path = require('path');
const yaml = require('js-yaml');
const SwaggerParser = require('@apidevtools/swagger-parser');

// This function recursively finds and prefixes all internal $ref values.
function updateRefs(obj, prefix) {
  for (const key in obj) {
    if (key === '$ref' && typeof obj[key] === 'string' && obj[key].startsWith('#/components/')) {
      const refParts = obj[key].split('/');
      const componentName = refParts.pop();
      // Only prefix if it's not already prefixed (idempotency)
      if (!componentName.startsWith(prefix)) {
        refParts.push(`${prefix}${componentName}`);
        obj[key] = refParts.join('/');
      }
    } else if (typeof obj[key] === 'object' && obj[key] !== null) {
      updateRefs(obj[key], prefix);
    }
  }
}

async function mergeApiSpecs() {
  const configPath = path.join(__dirname, '..', 'apis.yaml');
  const config = yaml.load(fs.readFileSync(configPath, 'utf8'));

  const masterSpec = {
    openapi: '3.0.3',
    info: {
      title: 'CAMARA Complete Unified API',
      version: new Date().toISOString().split('T')[0], // Use date as version
      description: 'A single OpenAPI spec generated by merging all active CAMARA project APIs. All paths and components are prefixed to ensure uniqueness.',
    },
    paths: {},
    components: {
      schemas: {},
      securitySchemes: {},
      responses: {},
      parameters: {},
    },
    security: [],
    tags: [],
  };

  for (const api of config.apis) {
    if (!api.enabled) {
      console.log(`Skipping disabled API: ${api.id}`);
      continue;
    }

    try {
      console.log(`Fetching and bundling API: ${api.id} from ${api.url}`);
      
      // CRITICAL FIX #1: Use SwaggerParser.bundle()
      // This resolves all external $refs (like common definitions) into a single, self-contained spec object.
      const spec = await SwaggerParser.bundle(api.url);

      const prefix = api.id;
      masterSpec.tags.push({ name: prefix, description: spec.info.title });

      // 1. Merge and prefix paths
      for (const p in spec.paths) {
        const newPath = `/${prefix.toLowerCase()}${p}`;
        const pathItem = spec.paths[p];
        
        // Iterate over methods (get, post, etc.)
        for (const method in pathItem) {
          const operation = pathItem[method];
          
          // CRITICAL FIX #2: Ensure unique operationId by prefixing it.
          if (operation.operationId) {
            operation.operationId = `${prefix}_${operation.operationId}`;
          }
          
          operation.tags = [prefix]; // Assign tag for easy grouping in UIs
        }
        
        updateRefs(pathItem, prefix); // Update any refs within the path definition
        masterSpec.paths[newPath] = pathItem;
      }

      // 2. Merge and prefix components
      if (spec.components) {
        for (const compType in spec.components) {
          if (!masterSpec.components[compType]) masterSpec.components[compType] = {};
          for (const compName in spec.components[compType]) {
            const newName = `${prefix}${compName}`;
            const component = spec.components[compType][compName];
            updateRefs(component, prefix); // Update any nested refs before adding
            masterSpec.components[compType][newName] = component;
          }
        }
      }
      
      // 3. Merge security schemes uniquely to avoid overwrites
      if (spec.components && spec.components.securitySchemes) {
        for (const schemeName in spec.components.securitySchemes) {
          if (!masterSpec.components.securitySchemes[schemeName]) {
            masterSpec.components.securitySchemes[schemeName] = spec.components.securitySchemes[schemeName];
          }
        }
      }

    } catch (error) {
      console.error(`Failed to process API ${api.id}:`, error.message);
    }
  }

  const outputPath = path.join(__dirname, '..', 'dist');
  if (!fs.existsSync(outputPath)) {
    fs.mkdirSync(outputPath);
  }
  fs.writeFileSync(
    path.join(outputPath, 'camara-complete.yaml'),
    yaml.dump(masterSpec, { noRefs: true, lineWidth: -1 }),
    'utf8'
  );

  console.log('Master OpenAPI spec generated successfully!');
}

mergeApiSpecs();
