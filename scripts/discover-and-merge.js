const fs = require('fs');
const path = require('path');
const { execSync } = require('child_process');
const yaml = require('js-yaml');
const SwaggerParser = require('@apidevtools/swagger-parser');
const semver = require('semver');
const apiRepositories = require('./api-repositories');

const ORG_NAME = 'camaraproject';
const TEMP_CLONE_DIR = path.join(__dirname, 'temp_clones');

function escapeRegExp(string) {
    return string.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
}

// Rewritten discovery logic for clarity and robustness with detailed logging.
function findLatestApiFile(directory) {
    console.log(`   -> Searching in directory: ${directory}`);
    if (!fs.existsSync(directory)) {
        console.log(`      - Directory does not exist.`);
        return null;
    }

    const files = fs.readdirSync(directory);
    let candidateFiles = [];

    for (const file of files) {
        if (file.startsWith('.') || (!file.endsWith('.yaml') && !file.endsWith('.yml'))) {
            continue; // Skip dotfiles and non-yaml files
        }

        const filePath = path.join(directory, file);
        if (!fs.statSync(filePath).isFile()) {
            continue; // Skip directories
        }
        
        console.log(`      - Found potential file: ${file}`);
        try {
            const content = fs.readFileSync(filePath, 'utf8');
            const doc = yaml.load(content);

            if (doc && (doc.openapi || doc.swagger)) {
                const versionMatch = file.match(/v(\d+\.\d+\.\d+)/);
                candidateFiles.push({
                    path: filePath,
                    name: file,
                    version: versionMatch ? versionMatch[1] : '0.0.0' // Default for non-versioned files
                });
                console.log(`         - PASSED VALIDATION: It's a valid OpenAPI file.`);
            } else {
                 console.log(`         - FAILED VALIDATION: Missing 'openapi' or 'swagger' key.`);
            }
        } catch (e) {
            console.log(`         - FAILED VALIDATION: Could not parse YAML. Error: ${e.message}`);
        }
    }

    if (candidateFiles.length === 0) {
        return null;
    }

    // Sort by semantic version, descending
    candidateFiles.sort((a, b) => semver.rcompare(a.version, b.version));
    
    const bestChoice = candidateFiles[0];
    console.log(`   -> Selected latest version: ${bestChoice.name}`);
    return bestChoice;
}


async function discoverApiUrlsByCloning() {
    if (fs.existsSync(TEMP_CLONE_DIR)) {
        fs.rmSync(TEMP_CLONE_DIR, { recursive: true, force: true });
    }
    fs.mkdirSync(TEMP_CLONE_DIR);

    console.log(`Discovering latest API files by cloning ${apiRepositories.length} repositories...`);
    const discoveredApis = [];

    for (const repoName of apiRepositories) {
        const repoUrl = `https://github.com/${ORG_NAME}/${repoName}.git`;
        const clonePath = path.join(TEMP_CLONE_DIR, repoName);
        try {
            console.log(`\n-> Cloning repository: ${repoName}`);
            execSync(`git clone --depth 1 ${repoUrl} "${clonePath}"`, { stdio: 'pipe' });

            const potentialPaths = [
                clonePath, // Root directory
                path.join(clonePath, 'dev', 'api-definitions'),
                path.join(clonePath, 'code', 'api-definitions')
            ];

            let foundFile = null;
            for (const apiPath of potentialPaths) {
                const file = findLatestApiFile(apiPath);
                if (file) {
                    foundFile = file;
                    break; 
                }
            }
            
            if (foundFile) {
                console.log(`   - SUCCESS: Final selection for ${repoName} is ${foundFile.name}`);
                discoveredApis.push({ id: repoName, url: foundFile.path });
            } else {
                 console.warn(`   - WARNING: No valid OpenAPI file found in any standard location for repository '${repoName}'.`);
            }

        } catch (error) {
            console.error(`   - FAILED to clone or process repository ${repoName}: ${error.message}`);
        }
    }

    console.log(`\nDiscovery complete. Found ${discoveredApis.length} valid API specifications.\n`);
    return discoveredApis;
}


async function mergeApiSpecs(apiList) {
    console.log('Starting merge process...');
    const masterSpec = {
        openapi: '3.0.3',
        info: {
            title: 'CAMARA Complete Unified API (Dynamically Generated)',
            version: new Date().toISOString(),
            description: 'A single OpenAPI spec generated by discovering and merging all active CAMARA project APIs.',
            license: { name: 'Apache 2.0', url: 'https://www.apache.org/licenses/LICENSE-2.0.html' },
        },
        servers: [{ url: 'https://api.example.com/camara', description: 'Example Production Server' }],
        paths: {},
        components: { schemas: {}, securitySchemes: {}, responses: {}, parameters: {}, examples: {}, requestBodies: {}, headers: {}, links: {}, callbacks: {} },
        security: [],
        tags: [],
    };
    for (const api of apiList) {
        try {
            console.log(`Processing API: ${api.id} from local path ${api.url}`);
            const spec = await SwaggerParser.bundle(api.url);
            const prefix = api.id;
            masterSpec.tags.push({ name: prefix, description: spec.info.title });
            let specString = JSON.stringify(spec);
            if (spec.components) {
                for (const compType in spec.components) {
                    for (const compName in spec.components[compType]) {
                        const originalRef = `#/components/${compType}/${compName}`;
                        const newRef = `#/components/${compType}/${prefix}${compName}`;
                        const searchRegex = new RegExp(`"${escapeRegExp(originalRef)}"`, 'g');
                        specString = specString.replace(searchRegex, `"${newRef}"`);
                    }
                }
            }
            const updatedSpec = JSON.parse(specString);
            if (updatedSpec.paths) {
                for (const p in updatedSpec.paths) {
                    const newPath = `/${prefix.toLowerCase()}${p}`;
                    const pathItem = updatedSpec.paths[p];
                    for (const method in pathItem) {
                        if (typeof pathItem[method] !== 'object' || pathItem[method] === null) continue;
                        const operation = pathItem[method];
                        if (operation.operationId) operation.operationId = `${prefix}_${operation.operationId}`;
                        operation.tags = [prefix];
                        if (operation.callbacks) {
                            for (const cbName in operation.callbacks) {
                                const callback = operation.callbacks[cbName];
                                for (const cbPath in callback) {
                                    const cbPathItem = callback[cbPath];
                                    for (const cbMethod in cbPathItem) {
                                        if (cbPathItem[cbMethod] && cbPathItem[cbMethod].operationId) {
                                            cbPathItem[cbMethod].operationId = `${prefix}_callback_${cbPathItem[cbMethod].operationId}`;
                                        }
                                    }
                                }
                            }
                        }
                    }
                    masterSpec.paths[newPath] = pathItem;
                }
            }
            if (updatedSpec.components) {
                for (const compType in updatedSpec.components) {
                    if (!masterSpec.components[compType]) masterSpec.components[compType] = {};
                    for (const compName in updatedSpec.components[compType]) {
                        const newName = `${prefix}${compName}`;
                        masterSpec.components[compType][newName] = updatedSpec.components[compType][compName];
                    }
                }
            }
            if (updatedSpec.components && updatedSpec.components.securitySchemes) {
                for (const schemeName in updatedSpec.components.securitySchemes) {
                    if (!masterSpec.components.securitySchemes[schemeName]) {
                        masterSpec.components.securitySchemes[schemeName] = updatedSpec.components.securitySchemes[schemeName];
                    }
                }
            }
        } catch (error) {
            console.error(`\n--- FATAL ERROR processing API: ${api.id} ---`);
            console.error(`File Path: ${api.url}`);
            console.error('An unrecoverable error occurred during the bundling or merging phase:');
            console.error(error);
            console.error('--- END FATAL ERROR ---\n');
            process.exit(1);
        }
    }
    const outputPath = path.join(__dirname, '..', 'dist');
    if (!fs.existsSync(outputPath)) {
        fs.mkdirSync(outputPath);
    }
    fs.writeFileSync(
        path.join(outputPath, 'camara-openapi.yaml'),
        yaml.dump(masterSpec, { noRefs: true, lineWidth: -1, quotingType: '"' }),
        'utf8'
    );
    console.log('Master OpenAPI spec generated successfully!');
    fs.rmSync(TEMP_CLONE_DIR, { recursive: true, force: true });
}


async function main() {
    const apiList = await discoverApiUrlsByCloning();
    if (apiList && apiList.length > 0) {
        await mergeApiSpecs(apiList);
    } else {
        console.error('No APIs were discovered. Halting build.');
        process.exit(1);
    }
}

main();
