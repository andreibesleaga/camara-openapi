// This script provides the definitive, production-grade solution.
// It uses a curated list of repositories and then dynamically discovers the
// latest valid OpenAPI file within each, making it resilient to upstream changes.
const fs = require('fs');
const path = require('path');
const { execSync } = require('child_process');
const yaml = require('js-yaml');
const semver = require('semver');
const SwaggerParser = require('@apidevtools/swagger-parser');
const apiRepoNames = require('./api-repositories.js');

const TEMP_CLONE_DIR = path.join(__dirname, 'temp_clones');

// Helper function to find the latest valid API file in a directory
function findLatestApiFile(directory) {
    if (!fs.existsSync(directory)) {
        console.log(`      - Directory does not exist.`);
        return null;
    }

    const files = fs.readdirSync(directory);
    let latestFile = null;
    let maxVersion = '0.0.0';

    for (const file of files) {
        if (file.endsWith('.yaml') || file.endsWith('.yml')) {
            const filePath = path.join(directory, file);
            // Basic validation: Check if it's a real OpenAPI file
            const content = fs.readFileSync(filePath, 'utf8');
            if (content.includes('openapi:') || content.includes('swagger:')) {
                console.log(`      - Found potential API file: ${file}`);
                // Use semver to find the highest version number in the filename
                const versionMatch = file.match(/v(\d+\.\d+\.\d+)/);
                const currentVersion = versionMatch ? versionMatch[1] : '0.0.0';

                if (semver.gt(currentVersion, maxVersion)) {
                    maxVersion = currentVersion;
                    latestFile = filePath;
                } else if (!latestFile && currentVersion === '0.0.0') {
                    // Fallback for non-versioned files
                    latestFile = filePath;
                }
            } else {
                 console.log(`      - Skipping non-OpenAPI file: ${file}`);
            }
        }
    }
    return latestFile;
}


async function discoverApis() {
    if (fs.existsSync(TEMP_CLONE_DIR)) {
        fs.rmSync(TEMP_CLONE_DIR, { recursive: true, force: true });
    }
    fs.mkdirSync(TEMP_CLONE_DIR);

    const discoveredApis = [];
    console.log(`Discovering latest API files from the curated list of ${apiRepoNames.length} repositories...`);

    for (const repoName of apiRepoNames) {
        const repoUrl = `https://github.com/camaraproject/${repoName}.git`;
        const clonePath = path.join(TEMP_CLONE_DIR, repoName);
        console.log(`-> Cloning repository: ${repoName}`);

        try {
            execSync(`git clone --depth 1 ${repoUrl} "${clonePath}"`, { stdio: 'pipe' });

            // Define search paths in order of priority
            const searchPaths = [
                clonePath, // Root directory
                path.join(clonePath, 'dev', 'api-definitions'),
                path.join(clonePath, 'code', 'api-definitions'),
            ];

            let foundFile = null;
            for (const searchPath of searchPaths) {
                console.log(`   -> Searching in directory: ${searchPath}`);
                foundFile = findLatestApiFile(searchPath);
                if (foundFile) {
                    console.log(`   - SUCCESS: Found API file: ${path.basename(foundFile)}`);
                    discoveredApis.push({ id: repoName, path: foundFile });
                    break;
                }
            }

            if (!foundFile) {
                console.log(`   - WARNING: No valid OpenAPI file found in any standard location for repository '${repoName}'.`);
            }
        } catch (error) {
            console.error(`   - FAILED to clone or process repository ${repoName}: ${error.message}`);
        }
    }
    console.log(`\nDiscovery complete. Found ${discoveredApis.length} valid API specifications.\n`);
    return discoveredApis;
}


async function mergeApiSpecs(discoveredApis) {
    if (discoveredApis.length === 0) {
        console.error('No APIs were discovered. Halting build.');
        process.exit(1);
    }
    console.log('Starting merge process...');

    const masterSpec = {
        openapi: '3.0.3',
        info: {
            title: 'CAMARA Complete Unified API (Manifest-Based)',
            version: new Date().toISOString(),
            description: 'A single OpenAPI spec generated by fetching and merging all CAMARA project APIs based on a definitive manifest.',
            license: {
                name: 'Apache 2.0',
                url: 'https://www.apache.org/licenses/LICENSE-2.0.html'
            }
        },
        servers: [{ url: 'https://api.example.com/camara', description: 'Example Production Server' }],
        paths: {},
        components: {
            schemas: {}, securitySchemes: {}, responses: {}, parameters: {},
            examples: {}, requestBodies: {}, headers: {}, links: {}, callbacks: {}
        },
        security: [],
        tags: [],
    };

    for (const api of discoveredApis) {
        try {
             console.log(`Processing API: ${api.id} from local path ${api.path}`);
             const spec = await SwaggerParser.bundle(api.path);
             // ... [Rest of the merge logic as before, it is correct]
             const prefix = api.id;
             masterSpec.tags.push({ name: prefix, description: spec.info.title });
             let specString = JSON.stringify(spec);
             if (spec.components) {
                 for (const compType in spec.components) {
                     for (const compName in spec.components[compType]) {
                         const originalRef = `#/components/${compType}/${compName}`;
                         const newRef = `#/components/${compType}/${prefix}${compName}`;
                         specString = specString.replace(new RegExp(`"${originalRef}"`, 'g'), `"${newRef}"`);
                     }
                 }
             }
             const updatedSpec = JSON.parse(specString);
             if (updatedSpec.paths) {
                 for (const p in updatedSpec.paths) {
                     const newPath = `/${prefix.toLowerCase()}${p.replace(/\/$/, '')}`;
                     const pathItem = updatedSpec.paths[p];
                     for (const method in pathItem) {
                         const op = pathItem[method];
                         if (op && op.operationId) {
                            op.operationId = `${prefix}_${op.operationId}`;
                            op.tags = [prefix];
                            if (op.callbacks) {
                                for(const cbName in op.callbacks){
                                    for(const cbPath in op.callbacks[cbName]){
                                        const cbOp = op.callbacks[cbName][cbPath];
                                        if(cbOp.post && cbOp.post.operationId){
                                            cbOp.post.operationId = `${prefix}_callback_${cbOp.post.operationId}`;
                                        }
                                    }
                                }
                            }
                         }
                     }
                     masterSpec.paths[newPath] = pathItem;
                 }
             }
             if (updatedSpec.components) {
                 for (const compType in updatedSpec.components) {
                     if (!masterSpec.components[compType]) masterSpec.components[compType] = {};
                     for (const compName in updatedSpec.components[compType]) {
                         const newName = `${prefix}${compName}`;
                         masterSpec.components[compType][newName] = updatedSpec.components[compType][compName];
                     }
                 }
             }
             if (updatedSpec.components && updatedSpec.components.securitySchemes) {
                Object.assign(masterSpec.components.securitySchemes, updatedSpec.components.securitySchemes);
            }
        } catch (error) {
             console.error(`\n--- FATAL ERROR processing API: ${api.id} ---`);
             console.error(`File Path: ${api.path}`);
             console.error('An unrecoverable error occurred during the bundling or merging phase:');
             console.error(error);
             console.error('--- END FATAL ERROR ---\n');
             process.exit(1);
        }
    }

    const outputPath = path.resolve(__dirname, '..', 'dist');
    if (!fs.existsSync(outputPath)) {
        fs.mkdirSync(outputPath);
    }
    fs.writeFileSync(
        path.join(outputPath, 'camara-openapi.yaml'),
        yaml.dump(masterSpec, { noRefs: true, lineWidth: -1, quotingType: '"' }),
        'utf8'
    );
    console.log('\nMaster OpenAPI spec generated successfully!');
}

async function main() {
    const discoveredApis = await discoverApis();
    await mergeApiSpecs(discoveredApis);
    // Cleanup
    if (fs.existsSync(TEMP_CLONE_DIR)) {
        fs.rmSync(TEMP_CLONE_DIR, { recursive: true, force: true });
    }
}

main().catch(error => {
    console.error('A critical error occurred:', error);
    if (fs.existsSync(TEMP_CLONE_DIR)) {
        fs.rmSync(TEMP_CLONE_DIR, { recursive: true, force: true });
    }
    process.exit(1);
});

