// This script provides the definitive, production-grade solution.
// It uses a curated manifest file (api-repositories.js) to locate the exact
// OpenAPI file within each repository, removing all guesswork and fixing the TypeError.
const fs = require('fs');
const path = require('path');
const { execSync } = require('child_process');
const yaml = require('js-yaml');
const SwaggerParser = require('@apidevtools/swagger-parser');
// The manifest file, which is an array of objects.
const apiDefinitions = require('./api-repositories.js');

const TEMP_CLONE_DIR = path.join(__dirname, 'temp_clones');


async function mergeApiSpecs(discoveredApis) {
    if (discoveredApis.length === 0) {
        console.error('No APIs were discovered. Halting build.');
        process.exit(1);
    }
    console.log('\nStarting merge process...');

    const masterSpec = {
        openapi: '3.0.3',
        info: {
            title: 'CAMARA Complete Unified API (Manifest-Based)',
            version: new Date().toISOString(),
            description: 'A single OpenAPI spec generated by fetching and merging all CAMARA project APIs based on a definitive manifest.',
            license: {
                name: 'Apache 2.0',
                url: 'https://www.apache.org/licenses/LICENSE-2.0.html'
            }
        },
        servers: [{ url: 'https://api.example.com/camara', description: 'Example Production Server' }],
        paths: {},
        components: {
            schemas: {}, securitySchemes: {}, responses: {}, parameters: {},
            examples: {}, requestBodies: {}, headers: {}, links: {}, callbacks: {}
        },
        security: [],
        tags: [],
    };

    for (const api of discoveredApis) {
        try {
             console.log(`-> Processing API: ${api.id} from local path ${api.path}`);
             const spec = await SwaggerParser.bundle(api.path);
             const prefix = api.id;
             masterSpec.tags.push({ name: prefix, description: spec.info.title });
             let specString = JSON.stringify(spec);
             if (spec.components) {
                 for (const compType in spec.components) {
                     for (const compName in spec.components[compType]) {
                         const originalRef = `#/components/${compType}/${compName}`;
                         const newRef = `#/components/${compType}/${prefix}${compName}`;
                         specString = specString.replace(new RegExp(`"${originalRef}"`, 'g'), `"${newRef}"`);
                     }
                 }
             }
             const updatedSpec = JSON.parse(specString);
             if (updatedSpec.paths) {
                 for (const p in updatedSpec.paths) {
                     const newPath = `/${prefix.toLowerCase()}${p.replace(/\/$/, '')}`;
                     const pathItem = updatedSpec.paths[p];
                     for (const method in pathItem) {
                         const op = pathItem[method];
                         if (op && typeof op === 'object' && op.operationId) {
                            op.operationId = `${prefix}_${op.operationId}`;
                            op.tags = [prefix];
                            if (op.callbacks) {
                                for(const cbName in op.callbacks){
                                    for(const cbPath in op.callbacks[cbName]){
                                        const cbOp = op.callbacks[cbName][cbPath];
                                        if(cbOp.post && cbOp.post.operationId){
                                            cbOp.post.operationId = `${prefix}_callback_${cbOp.post.operationId}`;
                                        }
                                    }
                                }
                            }
                         }
                     }
                     masterSpec.paths[newPath] = pathItem;
                 }
             }
             if (updatedSpec.components) {
                 for (const compType in updatedSpec.components) {
                     if (!masterSpec.components[compType]) masterSpec.components[compType] = {};
                     for (const compName in updatedSpec.components[compType]) {
                         const newName = `${prefix}${compName}`;
                         masterSpec.components[compType][newName] = updatedSpec.components[compType][compName];
                     }
                 }
             }
             if (updatedSpec.components && updatedSpec.components.securitySchemes) {
                Object.assign(masterSpec.components.securitySchemes, updatedSpec.components.securitySchemes);
            }
        } catch (error) {
             console.error(`\n--- FATAL ERROR processing API: ${api.id} ---`);
             console.error(`File Path: ${api.path}`);
             console.error('An unrecoverable error occurred during the bundling or merging phase:');
             console.error(error);
             console.error('--- END FATAL ERROR ---\n');
             process.exit(1);
        }
    }

    const outputPath = path.resolve(__dirname, '..', 'dist');
    if (!fs.existsSync(outputPath)) {
        fs.mkdirSync(outputPath);
    }
    fs.writeFileSync(
        path.join(outputPath, 'camara-openapi.yaml'),
        yaml.dump(masterSpec, { noRefs: true, lineWidth: -1, quotingType: '"' }),
        'utf8'
    );
    console.log('\nMaster OpenAPI spec generated successfully!');
}

async function main() {
    if (fs.existsSync(TEMP_CLONE_DIR)) {
        fs.rmSync(TEMP_CLONE_DIR, { recursive: true, force: true });
    }
    fs.mkdirSync(TEMP_CLONE_DIR);

    const discoveredApis = [];
    console.log(`Fetching ${apiDefinitions.length} APIs based on the definitive manifest...\n`);

    // 1. Get a unique list of repositories to clone from the manifest
    const reposToClone = [...new Set(apiDefinitions.map(api => api.repo))];

    // 2. Clone all necessary repositories
    for (const repoName of reposToClone) {
        const repoUrl = `https://github.com/camaraproject/${repoName}.git`;
        const clonePath = path.join(TEMP_CLONE_DIR, repoName);
        console.log(`-> Cloning repository: ${repoName}`);
        try {
            execSync(`git clone --depth 1 ${repoUrl} "${clonePath}"`, { stdio: 'pipe' });
        } catch (error) {
            console.error(`   - FAILED to clone repository ${repoName}: ${error.message}`);
        }
    }

    // 3. Verify the exact file path for each API from the manifest
    console.log('\nVerifying API file paths...');
    for (const api of apiDefinitions) {
        const fullPath = path.join(TEMP_CLONE_DIR, api.repo, api.path);
        if (fs.existsSync(fullPath)) {
            discoveredApis.push({ id: api.id, path: fullPath });
        } else {
            console.error(`   - FATAL ERROR: Could not find specified file for API '${api.id}'. Path does not exist: ${fullPath}`);
            process.exit(1);
        }
    }

    // 4. Merge the discovered APIs
    await mergeApiSpecs(discoveredApis);

    // 5. Cleanup
    if (fs.existsSync(TEMP_CLONE_DIR)) {
        fs.rmSync(TEMP_CLONE_DIR, { recursive: true, force: true });
    }
}

main().catch(error => {
    console.error('A critical error occurred:', error);
    if (fs.existsSync(TEMP_CLONE_DIR)) {
        fs.rmSync(TEMP_CLONE_DIR, { recursive: true, force: true });
    }
    process.exit(1);
});

