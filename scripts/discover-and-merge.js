const fs = require('fs');
const path = require('path');
const yaml = require('js-yaml');
const axios = require('axios');
const SwaggerParser = require('@apidevtools/swagger-parser');
const semver = require('semver');

const ORG_NAME = 'camaraproject';
const GITHUB_API_BASE_URL = 'https://api.github.com';

// CRITICAL FIX: Read the token from the environment variables provided by the GitHub Actions workflow.
const GITHUB_TOKEN = process.env.GITHUB_TOKEN;
const axiosInstance = axios.create({
    baseURL: GITHUB_API_BASE_URL,
    // Use the token for a much higher rate limit.
    headers: GITHUB_TOKEN ? { 'Authorization': `token ${GITHUB_TOKEN}` } : {},
});

// Helper function to escape strings for use in a RegExp
function escapeRegExp(string) {
    return string.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
}

/**
 * Finds the latest version of an API file in a list of files.
 */
function getLatestVersionedFile(files) {
    const versionedFiles = files
        .map(file => {
            const match = file.name.match(/v(\d+\.\d+\.\d+)/);
            return match ? { ...file, version: match[1] } : null;
        })
        .filter(Boolean);

    if (versionedFiles.length === 0) {
        return files.find(f => f.name.endsWith('.yaml') || f.name.endsWith('.yml'));
    }

    versionedFiles.sort((a, b) => semver.rcompare(a.version, b.version));
    return versionedFiles[0];
}

/**
 * Scans a CAMARA repository to find the primary OpenAPI specification file.
 */
async function findApiFileInRepo(repoName) {
    const potentialPaths = ['dev/api-definitions', 'code/api-definitions'];

    for (const apiPath of potentialPaths) {
        try {
            const { data: contents } = await axiosInstance.get(`/repos/${ORG_NAME}/${repoName}/contents/${apiPath}`);
            const yamlFiles = contents.filter(file => file.type === 'file' && (file.name.endsWith('.yaml') || file.name.endsWith('.yml')));

            if (yamlFiles.length > 0) {
                const latestFile = getLatestVersionedFile(yamlFiles);
                if (latestFile) {
                    console.log(`   - Found API file: ${latestFile.path}`);
                    return {
                        id: repoName,
                        url: latestFile.download_url,
                    };
                }
            }
        } catch (error) {
            if (error.response && error.response.status !== 404) {
                 // Log rate limit errors explicitly
                if (error.response.status === 403 || error.response.status === 429) {
                    console.error(`   - RATE LIMIT ERROR checking ${repoName}. Check GITHUB_TOKEN.`);
                }
            }
        }
    }
    return null;
}

/**
 * Discovers all valid CAMARA API spec URLs by scanning the GitHub organization.
 */
async function discoverApiUrls() {
    console.log(`Discovering APIs in the '${ORG_NAME}' GitHub organization...`);
    const discoveredApis = [];

    try {
        const { data: repos } = await axiosInstance.get(`/orgs/${ORG_NAME}/repos?per_page=100`);
        console.log(`Found ${repos.length} repositories. Scanning for API specs...`);
        
        // Exclude non-API repos to reduce unnecessary API calls
        const excludedRepos = new Set(['.github', 'Governance', 'Commonalities', 'IdentityAndConsentManagement', 'ReleaseManagement', 'project-administration', 'tooling', 'EasyCLA']);

        const apiPromises = repos
            .filter(repo => !repo.archived && !excludedRepos.has(repo.name))
            .map(async (repo) => {
                console.log(`-> Checking repo: ${repo.name}`);
                return await findApiFileInRepo(repo.name);
            });

        const results = await Promise.all(apiPromises);
        discoveredApis.push(...results.filter(Boolean));

    } catch (error) {
        console.error('FATAL: Could not discover APIs from GitHub.', error.message);
        if (error.response && (error.response.status === 403 || error.response.status === 429)) {
            console.error('This is likely a GitHub API rate limit issue. Ensure the GITHUB_TOKEN is being passed correctly to the script.');
        }
        process.exit(1);
    }

    console.log(`\nDiscovery complete. Found ${discoveredApis.length} valid API specifications.\n`);
    return discoveredApis;
}

async function mergeApiSpecs(apiList) {
    console.log('Starting merge process...');
    const masterSpec = {
        openapi: '3.0.3',
        info: {
            title: 'CAMARA Complete Unified API (Dynamically Generated)',
            version: new Date().toISOString(),
            description: 'A single OpenAPI spec generated by discovering and merging all active CAMARA project APIs.',
            license: { name: 'Apache 2.0', url: 'https://www.apache.org/licenses/LICENSE-2.0.html' },
        },
        servers: [{ url: 'https://api.example.com/camara', description: 'Example Production Server' }],
        paths: {},
        components: { schemas: {}, securitySchemes: {}, responses: {}, parameters: {}, examples: {}, requestBodies: {}, headers: {}, links: {}, callbacks: {} },
        security: [],
        tags: [],
    };

    for (const api of apiList) {
        try {
            console.log(`Processing API: ${api.id} from ${api.url}`);
            const spec = await SwaggerParser.bundle(api.url);
            const prefix = api.id;
            masterSpec.tags.push({ name: prefix, description: spec.info.title });
            
            let specString = JSON.stringify(spec);
            if (spec.components) {
                for (const compType in spec.components) {
                    for (const compName in spec.components[compType]) {
                        const originalRef = `#/components/${compType}/${compName}`;
                        const newRef = `#/components/${compType}/${prefix}${compName}`;
                        const searchRegex = new RegExp(`"${escapeRegExp(originalRef)}"`, 'g');
                        specString = specString.replace(searchRegex, `"${newRef}"`);
                    }
                }
            }
            const updatedSpec = JSON.parse(specString);

            if (updatedSpec.paths) {
                for (const p in updatedSpec.paths) {
                    const newPath = `/${prefix.toLowerCase()}${p}`;
                    const pathItem = updatedSpec.paths[p];
                    for (const method in pathItem) {
                        if (typeof pathItem[method] !== 'object' || pathItem[method] === null) continue;
                        const operation = pathItem[method];
                        if (operation.operationId) operation.operationId = `${prefix}_${operation.operationId}`;
                        operation.tags = [prefix];
                        if (operation.callbacks) {
                            for (const cbName in operation.callbacks) {
                                const callback = operation.callbacks[cbName];
                                for (const cbPath in callback) {
                                    const cbPathItem = callback[cbPath];
                                    for (const cbMethod in cbPathItem) {
                                        if (cbPathItem[cbMethod] && cbPathItem[cbMethod].operationId) {
                                            cbPathItem[cbMethod].operationId = `${prefix}_callback_${cbPathItem[cbMethod].operationId}`;
                                        }
                                    }
                                }
                            }
                        }
                    }
                    masterSpec.paths[newPath] = pathItem;
                }
            }
            if (updatedSpec.components) {
                for (const compType in updatedSpec.components) {
                    if (!masterSpec.components[compType]) masterSpec.components[compType] = {};
                    for (const compName in updatedSpec.components[compType]) {
                        const newName = `${prefix}${compName}`;
                        masterSpec.components[compType][newName] = updatedSpec.components[compType][compName];
                    }
                }
            }
            if (updatedSpec.components && updatedSpec.components.securitySchemes) {
                for (const schemeName in updatedSpec.components.securitySchemes) {
                    if (!masterSpec.components.securitySchemes[schemeName]) {
                        masterSpec.components.securitySchemes[schemeName] = updatedSpec.components.securitySchemes[schemeName];
                    }
                }
            }
        } catch (error) {
            console.error(`\n--- FATAL ERROR processing API: ${api.id} ---`);
            console.error(`URL: ${api.url}`);
            console.error('An unrecoverable error occurred during the bundling or merging phase:');
            console.error(error);
            console.error('--- END FATAL ERROR ---\n');
            process.exit(1);
        }
    }

    const outputPath = path.join(__dirname, '..', 'dist');
    if (!fs.existsSync(outputPath)) {
        fs.mkdirSync(outputPath);
    }
    fs.writeFileSync(
        path.join(outputPath, 'camara-openapi.yaml'),
        yaml.dump(masterSpec, { noRefs: true, lineWidth: -1, quotingType: '"' }),
        'utf8'
    );

    console.log('Master OpenAPI spec generated successfully!');
}

async function main() {
    const apiList = await discoverApiUrls();
    if (apiList && apiList.length > 0) {
        await mergeApiSpecs(apiList);
    } else {
        console.error('No APIs were discovered. Halting build.');
        process.exit(1);
    }
}

main();
