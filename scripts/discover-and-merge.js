const fs = require('fs');
const path = require('path');
const { execSync } = require('child_process');
const yaml = require('js-yaml');
const SwaggerParser = require('@apidevtools/swagger-parser');
const semver = require('semver');
const apiRepositories = require('./api-repositories');

const ORG_NAME = 'camaraproject';
const TEMP_CLONE_DIR = path.join(__dirname, 'temp_clones');

function escapeRegExp(string) {
    return string.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
}

// This function checks if a file is a REAL OpenAPI spec by reading its content.
function isValidOpenApiFile(filePath) {
    try {
        const fileContent = fs.readFileSync(filePath, 'utf8');
        // Ignore files that are clearly not OpenAPI specs (e.g., small config files)
        if (fileContent.length < 50) return false;
        
        const doc = yaml.load(fileContent);
        return doc && (doc.openapi || doc.swagger);
    } catch (e) {
        // Not a valid YAML or other error
        return false;
    }
}

function getLatestVersionedFile(files, dirPath) {
    const validApiFiles = files.filter(fileName => isValidOpenApiFile(path.join(dirPath, fileName)));

    const versionedFiles = validApiFiles
        .map(fileName => {
            const match = fileName.match(/v(\d+\.\d+\.\d+)/);
            return match ? { name: fileName, version: match[1], path: path.join(dirPath, fileName) } : null;
        })
        .filter(Boolean);

    if (versionedFiles.length === 0) {
        const nonVersionedFile = validApiFiles[0]; // Pick the first valid one found
        return nonVersionedFile ? { name: nonVersionedFile, path: path.join(dirPath, nonVersionedFile) } : null;
    }

    versionedFiles.sort((a, b) => semver.rcompare(a.version, b.version));
    return versionedFiles[0];
}

function findApiFileInDir(dirPath) {
    if (!fs.existsSync(dirPath)) {
        return null;
    }
    const entries = fs.readdirSync(dirPath);
    // Ignore dotfiles like .spectral.yml immediately.
    const yamlFiles = entries.filter(file => 
        fs.statSync(path.join(dirPath, file)).isFile() &&
        (file.endsWith('.yaml') || file.endsWith('.yml')) &&
        !file.startsWith('.') 
    );

    if (yamlFiles.length > 0) {
        return getLatestVersionedFile(yamlFiles, dirPath);
    }
    return null;
}

async function discoverApiUrlsByCloning() {
    if (fs.existsSync(TEMP_CLONE_DIR)) {
        fs.rmSync(TEMP_CLONE_DIR, { recursive: true, force: true });
    }
    fs.mkdirSync(TEMP_CLONE_DIR);

    console.log(`Discovering latest API files by cloning ${apiRepositories.length} repositories...`);
    const discoveredApis = [];

    for (const repoName of apiRepositories) {
        const repoUrl = `https://github.com/${ORG_NAME}/${repoName}.git`;
        const clonePath = path.join(TEMP_CLONE_DIR, repoName);
        try {
            console.log(`-> Cloning repository: ${repoName}`);
            execSync(`git clone --depth 1 ${repoUrl} "${clonePath}"`, { stdio: 'pipe' });

            const potentialPaths = [
                clonePath, // Root directory
                path.join(clonePath, 'dev', 'api-definitions'),
                path.join(clonePath, 'code', 'api-definitions')
            ];

            let foundFile = null;
            for (const apiPath of potentialPaths) {
                const file = findApiFileInDir(apiPath);
                if (file) {
                    foundFile = file;
                    break;
                }
            }
            
            if (foundFile) {
                console.log(`   - SUCCESS: Found and validated API file: ${foundFile.name}`);
                discoveredApis.push({ id: repoName, url: foundFile.path });
            } else {
                 console.warn(`   - WARNING: No valid OpenAPI file found in standard locations for repository '${repoName}'.`);
            }

        } catch (error) {
            console.error(`   - FAILED to clone or process repository ${repoName}: ${error.message}`);
        }
    }

    console.log(`\nDiscovery complete. Found ${discoveredApis.length} valid API specifications.\n`);
    return discoveredApis;
}


async function mergeApiSpecs(apiList) {
    console.log('Starting merge process...');
    const masterSpec = {
        openapi: '3.0.3',
        info: {
            title: 'CAMARA Complete Unified API (Dynamically Generated)',
            version: new Date().toISOString(),
            description: 'A single OpenAPI spec generated by discovering and merging all active CAMARA project APIs.',
            license: { name: 'Apache 2.0', url: 'https://www.apache.org/licenses/LICENSE-2.0.html' },
        },
        servers: [{ url: 'https://api.example.com/camara', description: 'Example Production Server' }],
        paths: {},
        components: { schemas: {}, securitySchemes: {}, responses: {}, parameters: {}, examples: {}, requestBodies: {}, headers: {}, links: {}, callbacks: {} },
        security: [],
        tags: [],
    };
    for (const api of apiList) {
        try {
            console.log(`Processing API: ${api.id} from local path ${api.url}`);
            const spec = await SwaggerParser.bundle(api.url);
            const prefix = api.id;
            masterSpec.tags.push({ name: prefix, description: spec.info.title });
            let specString = JSON.stringify(spec);
            if (spec.components) {
                for (const compType in spec.components) {
                    for (const compName in spec.components[compType]) {
                        const originalRef = `#/components/${compType}/${compName}`;
                        const newRef = `#/components/${compType}/${prefix}${compName}`;
                        const searchRegex = new RegExp(`"${escapeRegExp(originalRef)}"`, 'g');
                        specString = specString.replace(searchRegex, `"${newRef}"`);
                    }
                }
            }
            const updatedSpec = JSON.parse(specString);
            if (updatedSpec.paths) {
                for (const p in updatedSpec.paths) {
                    const newPath = `/${prefix.toLowerCase()}${p}`;
                    const pathItem = updatedSpec.paths[p];
                    for (const method in pathItem) {
                        if (typeof pathItem[method] !== 'object' || pathItem[method] === null) continue;
                        const operation = pathItem[method];
                        if (operation.operationId) operation.operationId = `${prefix}_${operation.operationId}`;
                        operation.tags = [prefix];
                        if (operation.callbacks) {
                            for (const cbName in operation.callbacks) {
                                const callback = operation.callbacks[cbName];
                                for (const cbPath in callback) {
                                    const cbPathItem = callback[cbPath];
                                    for (const cbMethod in cbPathItem) {
                                        if (cbPathItem[cbMethod] && cbPathItem[cbMethod].operationId) {
                                            cbPathItem[cbMethod].operationId = `${prefix}_callback_${cbPathItem[cbMethod].operationId}`;
                                        }
                                    }
                                }
                            }
                        }
                    }
                    masterSpec.paths[newPath] = pathItem;
                }
            }
            if (updatedSpec.components) {
                for (const compType in updatedSpec.components) {
                    if (!masterSpec.components[compType]) masterSpec.components[compType] = {};
                    for (const compName in updatedSpec.components[compType]) {
                        const newName = `${prefix}${compName}`;
                        masterSpec.components[compType][newName] = updatedSpec.components[compType][compName];
                    }
                }
            }
            if (updatedSpec.components && updatedSpec.components.securitySchemes) {
                for (const schemeName in updatedSpec.components.securitySchemes) {
                    if (!masterSpec.components.securitySchemes[schemeName]) {
                        masterSpec.components.securitySchemes[schemeName] = updatedSpec.components.securitySchemes[schemeName];
                    }
                }
            }
        } catch (error) {
            console.error(`\n--- FATAL ERROR processing API: ${api.id} ---`);
            console.error(`File Path: ${api.url}`);
            console.error('An unrecoverable error occurred during the bundling or merging phase:');
            console.error(error);
            console.error('--- END FATAL ERROR ---\n');
            process.exit(1);
        }
    }
    const outputPath = path.join(__dirname, '..', 'dist');
    if (!fs.existsSync(outputPath)) {
        fs.mkdirSync(outputPath);
    }
    fs.writeFileSync(
        path.join(outputPath, 'camara-openapi.yaml'),
        yaml.dump(masterSpec, { noRefs: true, lineWidth: -1, quotingType: '"' }),
        'utf8'
    );
    console.log('Master OpenAPI spec generated successfully!');
    fs.rmSync(TEMP_CLONE_DIR, { recursive: true, force: true });
}


async function main() {
    const apiList = await discoverApiUrlsByCloning();
    if (apiList && apiList.length > 0) {
        await mergeApiSpecs(apiList);
    } else {
        console.error('No APIs were discovered. Halting build.');
        process.exit(1);
    }
}

main();
