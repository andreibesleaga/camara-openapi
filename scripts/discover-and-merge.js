const fs = require('fs');
const path = require('path');
const { execSync } = require('child_process');
const yaml = require('js-yaml');
const SwaggerParser = require('@apidevtools/swagger-parser');
const apiDefinitions = require('./api-repositories'); // Using the new manifest file

const ORG_NAME = 'camaraproject';
const TEMP_CLONE_DIR = path.join(__dirname, 'temp_clones');

function escapeRegExp(string) {
    return string.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
}

async function fetchApisFromManifest() {
    if (fs.existsSync(TEMP_CLONE_DIR)) {
        fs.rmSync(TEMP_CLONE_DIR, { recursive: true, force: true });
    }
    fs.mkdirSync(TEMP_CLONE_DIR);

    console.log(`Fetching ${apiDefinitions.length} APIs based on the definitive manifest...`);
    const discoveredApis = [];
    const clonedRepos = new Set();

    for (const api of apiDefinitions) {
        try {
            const clonePath = path.join(TEMP_CLONE_DIR, api.repo);

            // Clone the repository only if we haven't already
            if (!clonedRepos.has(api.repo)) {
                console.log(`\n-> Cloning repository: ${api.repo}`);
                const repoUrl = `https://github.com/${ORG_NAME}/${api.repo}.git`;
                execSync(`git clone --depth 1 ${repoUrl} "${clonePath}"`, { stdio: 'pipe' });
                clonedRepos.add(api.repo);
            }

            const apiFilePath = path.join(clonePath, api.path);

            if (fs.existsSync(apiFilePath)) {
                console.log(`   - SUCCESS: Located API '${api.id}' at '${api.path}'`);
                discoveredApis.push({ id: api.id, url: apiFilePath });
            } else {
                console.error(`   - FATAL ERROR: Could not find specified file for API '${api.id}'. Path does not exist: ${apiFilePath}`);
                // In this new model, a missing file is a critical error.
                process.exit(1); 
            }

        } catch (error) {
            console.error(`   - FAILED to clone or process repository for API '${api.id}': ${error.message}`);
        }
    }

    console.log(`\nFetch complete. Found ${discoveredApis.length} valid API specifications.\n`);
    return discoveredApis;
}

async function mergeApiSpecs(apiList) {
    console.log('Starting merge process...');
    const masterSpec = {
        openapi: '3.0.3',
        info: {
            title: 'CAMARA Complete Unified API (Manifest-Based)',
            version: new Date().toISOString(),
            description: 'A single OpenAPI spec generated by fetching and merging all CAMARA project APIs based on a definitive manifest.',
            license: { name: 'Apache 2.0', url: 'https://www.apache.org/licenses/LICENSE-2.0.html' },
        },
        servers: [{ url: 'https://api.example.com/camara', description: 'Example Production Server' }],
        paths: {},
        components: { schemas: {}, securitySchemes: {}, responses: {}, parameters: {}, examples: {}, requestBodies: {}, headers: {}, links: {}, callbacks: {} },
        security: [],
        tags: [],
    };
    for (const api of apiList) {
        try {
            console.log(`Processing API: ${api.id} from local path ${api.url}`);
            const spec = await SwaggerParser.bundle(api.url);
            const prefix = api.id;
            masterSpec.tags.push({ name: prefix, description: spec.info.title });
            let specString = JSON.stringify(spec);
            if (spec.components) {
                for (const compType in spec.components) {
                    for (const compName in spec.components[compType]) {
                        const originalRef = `#/components/${compType}/${compName}`;
                        const newRef = `#/components/${compType}/${prefix}${compName}`;
                        const searchRegex = new RegExp(`"${escapeRegExp(originalRef)}"`, 'g');
                        specString = specString.replace(searchRegex, `"${newRef}"`);
                    }
                }
            }
            const updatedSpec = JSON.parse(specString);
            if (updatedSpec.paths) {
                for (const p in updatedSpec.paths) {
                    const newPath = `/${prefix.toLowerCase()}${p}`;
                    const pathItem = updatedSpec.paths[p];
                    for (const method in pathItem) {
                        if (typeof pathItem[method] !== 'object' || pathItem[method] === null) continue;
                        const operation = pathItem[method];
                        if (operation.operationId) operation.operationId = `${prefix}_${operation.operationId}`;
                        operation.tags = [prefix];
                        if (operation.callbacks) {
                            for (const cbName in operation.callbacks) {
                                const callback = operation.callbacks[cbName];
                                for (const cbPath in callback) {
                                    const cbPathItem = callback[cbPath];
                                    for (const cbMethod in cbPathItem) {
                                        if (cbPathItem[cbMethod] && cbPathItem[cbMethod].operationId) {
                                            cbPathItem[cbMethod].operationId = `${prefix}_callback_${cbPathItem[cbMethod].operationId}`;
                                        }
                                    }
                                }
                            }
                        }
                    }
                    masterSpec.paths[newPath] = pathItem;
                }
            }
            if (updatedSpec.components) {
                for (const compType in updatedSpec.components) {
                    if (!masterSpec.components[compType]) masterSpec.components[compType] = {};
                    for (const compName in updatedSpec.components[compType]) {
                        const newName = `${prefix}${compName}`;
                        masterSpec.components[compType][newName] = updatedSpec.components[compType][compName];
                    }
                }
            }
            if (updatedSpec.components && updatedSpec.components.securitySchemes) {
                for (const schemeName in updatedSpec.components.securitySchemes) {
                    if (!masterSpec.components.securitySchemes[schemeName]) {
                        masterSpec.components.securitySchemes[schemeName] = updatedSpec.components.securitySchemes[schemeName];
                    }
                }
            }
        } catch (error) {
            console.error(`\n--- FATAL ERROR processing API: ${api.id} ---`);
            console.error(`File Path: ${api.url}`);
            console.error('An unrecoverable error occurred during the bundling or merging phase:');
            console.error(error);
            console.error('--- END FATAL ERROR ---\n');
            process.exit(1);
        }
    }
    const outputPath = path.join(__dirname, '..', 'dist');
    if (!fs.existsSync(outputPath)) {
        fs.mkdirSync(outputPath);
    }
    fs.writeFileSync(
        path.join(outputPath, 'camara-openapi.yaml'),
        yaml.dump(masterSpec, { noRefs: true, lineWidth: -1, quotingType: '"' }),
        'utf8'
    );
    console.log('Master OpenAPI spec generated successfully!');
    fs.rmSync(TEMP_CLONE_DIR, { recursive: true, force: true });
}

async function main() {
    const apiList = await fetchApisFromManifest();
    if (apiList && apiList.length > 0) {
        await mergeApiSpecs(apiList);
    } else {
        console.error('No APIs were located based on the manifest. Halting build.');
        process.exit(1);
    }
}

main();
